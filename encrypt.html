<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="fevicon.png">
    <title>AES-256 Local File Encryptor/Decryptor</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Crypto-JS library for AES-256 encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <!-- Load JSZip library for multiple file handling (ZIP creation/extraction) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* Apply Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d0d; /* Deep black background */
        }
        /* Button colors and gradient */
        .btn-encrypt {
            background-image: linear-gradient(to right, #ef4444 0%, #dc2626 51%, #ef4444 100%);
        }
        .btn-decrypt {
            background-image: linear-gradient(to right, #3b82f6 0%, #2563eb 51%, #3b82f6 100%);
        }
        /* Base button styling for consistent size and look */
        .btn-base {
            /* Uses padding instead of separate px/py classes for cleaner definition */
            padding: 0.75rem 1.5rem; 
            text-align: center;
            transition: 0.5s;
            background-size: 200% auto;
            color: white;
            border-radius: 10px;
            display: block;
            width: 100%; /* Ensures flex-1 works correctly */
        }
        .btn-base:hover {
            background-position: right center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        /* Custom file input styling */
        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-container input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body class="min-h-screen flex items-center justify-center p-4">

    <div id="app" class="w-full max-w-xl bg-gray-900 border border-gray-800 rounded-xl shadow-2xl p-6 md:p-10">

        <h1 class="text-3xl font-bold text-center mb-6 text-red-500">
            Secure Local File Encryption
        </h1>
        <p class="text-gray-400 text-center mb-8">
            Encrypt and decrypt your files using AES-256 client-side. All processing is done in your browser.
        </p>

        <!-- File Input and Display -->
        <div class="mb-6">
            <label class="block text-sm font-medium text-gray-300 mb-2">1. Select File(s)</label>
            <div class="file-input-container w-full">
                <button type="button" id="fileSelectButton" class="w-full px-4 py-3 bg-gray-700 hover:bg-gray-600 text-white rounded-lg transition duration-200">
                    <span id="fileNameDisplay">Click to Select File(s) (or Encrypted .enc/.zip)</span>
                </button>
                <!-- Removed 'webkitdirectory' to prevent folder selection -->
                <input type="file" id="fileInput" class="w-full" multiple>
            </div>
        </div>

        <!-- Password Input -->
        <div class="mb-8">
            <label for="passwordInput" class="block text-sm font-medium text-gray-300 mb-2">2. Enter Secret Passphrase (AES Key)</label>
            <input type="password" id="passwordInput" placeholder="Enter a strong, memorable password"
                   class="w-full px-4 py-3 bg-gray-800 border border-gray-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 transition duration-200">
        </div>

        <!-- Action Buttons - Flex container ensures same size (flex-1) -->
        <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4">
            <button id="encryptButton" class="flex-1 btn-base btn-encrypt font-semibold shadow-lg hover:shadow-red-700/50">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd" />
                </svg>
                Encrypt File(s)
            </button>
            <button id="decryptButton" class="flex-1 btn-base btn-decrypt font-semibold shadow-lg hover:shadow-blue-700/50">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75L10 8l2.905-1.75A5 5 0 0010 2z" />
                </svg>
                Decrypt File/ZIP
            </button>
        </div>

        <!-- Status Message Area -->
        <div id="statusMessage" class="mt-8 p-4 bg-gray-800 border-l-4 border-red-500 text-gray-300 rounded-lg hidden">
            <p id="statusText" class="text-sm"></p>
        </div>

        <!-- Error/Warning Modal (instead of alert) -->
        <div id="modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
            <div class="bg-gray-900 rounded-xl p-6 w-full max-w-sm border border-red-500 shadow-xl">
                <h3 id="modalTitle" class="text-xl font-semibold text-red-500 mb-3">Error</h3>
                <p id="modalBody" class="text-gray-300 mb-4 text-sm"></p>
                <button id="modalCloseButton" class="w-full px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg font-medium transition duration-200">
                    Close
                </button>
            </div>
        </div>

    </div>

    <script>
        // Global element references
        const fileInput = document.getElementById('fileInput');
        const passwordInput = document.getElementById('passwordInput');
        const encryptButton = document.getElementById('encryptButton');
        const decryptButton = document.getElementById('decryptButton');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const fileSelectButton = document.getElementById('fileSelectButton');
        const statusMessage = document.getElementById('statusMessage');
        const statusText = document.getElementById('statusText');
        
        // Modal elements
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalCloseButton = document.getElementById('modalCloseButton');

        // Stores the array of selected files
        let selectedFiles = []; 

        // --- Utility Functions ---

        /** Shows a custom modal instead of using alert() */
        function showModal(title, message) {
            modalTitle.textContent = title;
            modalBody.textContent = message;
            modal.classList.remove('hidden');
        }

        modalCloseButton.onclick = () => {
            modal.classList.add('hidden');
        };

        /** Displays the status message temporarily */
        function showStatus(message, isError = false) {
            statusText.textContent = message;
            statusMessage.classList.remove('hidden');
            statusMessage.style.borderColor = isError ? '#ef4444' : '#3b82f6';
            
            // Hide the status after 7 seconds
            setTimeout(() => {
                statusMessage.classList.add('hidden');
            }, 7000);
        }

        /** Converts a File object to an ArrayBuffer */
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Error reading file: ' + e.target.error.message));
                reader.readAsArrayBuffer(file);
            });
        }
        
        /** Converts an ArrayBuffer to a Base64 string */
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        /** Converts a Base64 string back to an ArrayBuffer */
        function base64ToArrayBuffer(base64) {
            const binary_string = atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /** Triggers a browser download for the given data (Blob or ArrayBuffer) */
        function downloadFile(data, fileName, mimeType) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- Core Crypto and File Handling Functions ---

        /** Encrypts the selected files/folder content and triggers download (.enc or .zip) */
        async function handleEncrypt() {
            if (selectedFiles.length === 0) {
                return showModal('File Error', 'Please select one or more files first.');
            }
            const password = passwordInput.value;
            if (password.length < 8) {
                return showModal('Security Warning', 'Please use a passphrase of at least 8 characters for stronger security.');
            }

            showStatus(`Encrypting ${selectedFiles.length} item(s)... Please wait.`, false);
            encryptButton.disabled = true;
            decryptButton.disabled = true;

            try {
                const isSingleFile = selectedFiles.length === 1;
                const fileToProcess = selectedFiles[0];

                if (isSingleFile) {
                    // --- SINGLE FILE MODE (Output: file.txt.enc) ---
                    const fileBuffer = await readFileAsArrayBuffer(fileToProcess);
                    const base64File = arrayBufferToBase64(fileBuffer);
                    const encryptedString = CryptoJS.AES.encrypt(base64File, password).toString(); 
                    
                    const encryptedFileName = fileToProcess.name + '.enc';
                    downloadFile(encryptedString, encryptedFileName, 'application/octet-stream');
                    showStatus(`Encryption successful! Downloaded: ${encryptedFileName}`, false);

                } else {
                    // --- MULTI-FILE MODE (Output: Encrypted_Files.zip) ---
                    const zip = new JSZip();
                    const outputFileName = 'Encrypted_Files.zip';
                    let fileCount = 0;

                    for (const file of selectedFiles) {
                        if (file.size === 0) continue; 
                        const fileBuffer = await readFileAsArrayBuffer(file);
                        const base64File = arrayBufferToBase64(fileBuffer);
                        const encrypted = CryptoJS.AES.encrypt(base64File, password).toString(); 

                        // Use only the file name
                        const zipPath = file.name;
                        
                        // Encrypt contents within the zip with the .enc extension
                        zip.file(zipPath + '.enc', encrypted); 
                        fileCount++;
                    }
                    
                    if (fileCount === 0) {
                         showModal('Processing Error', 'No readable files found in the selection.');
                         return;
                    }

                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    downloadFile(zipBlob, outputFileName, 'application/zip');
                    showStatus(`Encryption successful! Downloaded: ${outputFileName} containing ${fileCount} file(s).`, false);
                }

            } catch (error) {
                console.error('Encryption failed:', error);
                showModal('Encryption Failed', `An error occurred during encryption: ${error.message}`);
            } finally {
                encryptButton.disabled = false;
                decryptButton.disabled = false;
            }
        }

        /** Decrypts the selected content and triggers download (file.txt or .zip) */
        async function handleDecrypt() {
            if (selectedFiles.length !== 1) {
                return showModal('File Error', 'Please select exactly ONE encrypted file (.enc) or one encrypted ZIP file.');
            }
            const encryptedFile = selectedFiles[0];
            const password = passwordInput.value;

            if (!password) {
                return showModal('Password Required', 'Please enter the password used for encryption.');
            }

            showStatus('Attempting decryption...');
            encryptButton.disabled = true;
            decryptButton.disabled = true;

            try {
                if (encryptedFile.name.toLowerCase().endsWith('.enc')) {
                    // --- SINGLE FILE MODE (Input: file.txt.enc) ---
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const encryptedString = e.target.result;
                        try {
                            const decrypted = CryptoJS.AES.decrypt(encryptedString, password);
                            
                            if (decrypted.sigBytes <= 0) {
                                showModal('Decryption Failed', 'Invalid password or corrupted file.');
                                return;
                            }

                            const base64Original = decrypted.toString(CryptoJS.enc.Utf8);
                            if (!base64Original) {
                                 showModal('Decryption Failed', 'Corrupted file data. Resulting content is empty.');
                                 return;
                            }
                            const originalBuffer = base64ToArrayBuffer(base64Original);

                            // Remove the .enc extension to restore original name (e.g., hello.txt.enc -> hello.txt)
                            let originalFileName = encryptedFile.name.slice(0, -4); 
                            downloadFile(originalBuffer, originalFileName, 'application/octet-stream');
                            
                            showStatus(`Decryption successful! Downloaded: ${originalFileName}`, false);

                        } catch (cryptoError) {
                            console.error('Decryption failed at crypto step:', cryptoError);
                            showModal('Decryption Failed', 'The input file format is invalid or the password is incorrect.');
                        } finally {
                            encryptButton.disabled = false;
                            decryptButton.disabled = false;
                        }
                    };
                    reader.onerror = () => showModal('File Read Error', 'Could not read the encrypted file.');
                    reader.readAsText(encryptedFile);

                } else if (encryptedFile.name.toLowerCase().endsWith('.zip')) {
                    // --- ZIP FILE MODE (Input: Encrypted_Files.zip) ---
                    const zipBuffer = await readFileAsArrayBuffer(encryptedFile);
                    const zip = await JSZip.loadAsync(zipBuffer);
                    const outputZip = new JSZip();
                    
                    let successfulDecryptions = 0;
                    let failedDecryptions = 0;
                    
                    for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
                        if (zipEntry.dir) continue;
                        
                        const encryptedString = await zipEntry.async("text");
                        
                        try {
                            const decrypted = CryptoJS.AES.decrypt(encryptedString, password);
                            
                            if (decrypted.sigBytes <= 0) {
                                failedDecryptions++;
                                continue;
                            }

                            const base64Original = decrypted.toString(CryptoJS.enc.Utf8);
                            if (!base64Original) continue;

                            const originalBuffer = base64ToArrayBuffer(base64Original);

                            // Remove the .enc extension for the original file path
                            let originalPath = relativePath;
                            if (originalPath.endsWith('.enc')) {
                                originalPath = originalPath.slice(0, -4);
                            } 
                            
                            outputZip.file(originalPath, originalBuffer);
                            successfulDecryptions++;

                        } catch (cryptoError) {
                            failedDecryptions++;
                        }
                    }
                    
                    if (successfulDecryptions === 0) {
                        showModal('Decryption Failed', `Could not decrypt any files. Check your password. (Files failed: ${failedDecryptions})`);
                        return;
                    }

                    // Create output file name: e.g., 'Encrypted_Files.zip' -> 'Decrypted_Files.zip'
                    let outputFileName = encryptedFile.name.replace('.zip', 'Decrypted.zip');
                    if (outputFileName.includes('Encrypted')) {
                        outputFileName = outputFileName.replace('Encrypted', 'Decrypted');
                    } else {
                         outputFileName = 'Decrypted_' + outputFileName;
                    }
                    
                    const outputZipBlob = await outputZip.generateAsync({ type: "blob" });
                    downloadFile(outputZipBlob, outputFileName, 'application/zip');
                    
                    showStatus(`Decryption successful! Downloaded: ${outputFileName}. (Decrypted: ${successfulDecryptions}, Failed: ${failedDecryptions})`, false);

                } else {
                    showModal('File Type Error', 'The selected file must be a single encrypted file (.enc) or an encrypted ZIP file.');
                    return;
                }

            } catch (error) {
                console.error('Overall Decryption failed:', error);
                showModal('Decryption Failed', `An unexpected error occurred: ${error.message}`);
            } finally {
                encryptButton.disabled = false;
                decryptButton.disabled = false;
            }
        }


        // --- Event Listeners ---

        fileInput.addEventListener('change', (e) => {
            // Filter out zero-size files/metadata which can happen with certain file selections
            selectedFiles = Array.from(e.target.files).filter(f => f.size > 0); 
            
            if (selectedFiles.length > 0) {
                const fileCount = selectedFiles.length;
                const firstName = selectedFiles[0].name;
                
                let fileDisplay;
                if (fileCount > 1) {
                    fileDisplay = `${fileCount} files selected (e.g., ${firstName}, ...)`;
                } else {
                    fileDisplay = firstName;
                }

                fileNameDisplay.textContent = fileDisplay;
                showStatus(`${fileCount} file(s) ready for processing.`, false);
            } else {
                fileNameDisplay.textContent = 'Click to Select File(s) (or Encrypted .enc/.zip)';
                selectedFiles = [];
                statusMessage.classList.add('hidden');
            }
        });
        
        fileSelectButton.addEventListener('click', () => {
             // Programmatically trigger the hidden file input click
             fileInput.click(); 
        });


        encryptButton.addEventListener('click', handleEncrypt);
        decryptButton.addEventListener('click', handleDecrypt);

    </script>
</body>
</html>
